// ========================================
// POWER QUERY M КОД ДЛЯ ИНТЕГРАЦИИ SQL
// Analytics Course: github.com/lazuale/analytics-course
// Глава 19: SQL - основные запросы, агрегаты, GROUP BY
// ========================================

// Этот файл содержит готовые примеры M кода для интеграции
// SQLite базы данных с Power BI Desktop и Excel Power Query

// ========================================
// 1. БАЗОВОЕ ПОДКЛЮЧЕНИЕ К SQLITE
// ========================================

// Подключение к файлу SQLite базы данных
let
    // ВАЖНО: Замените путь на реальный путь к вашему файлу
    DatabasePath = "C:\path\to\your\ecommerce_database.db",
    
    // Подключение к базе данных
    Source = Sqlite.Database(File.Contents(DatabasePath)),
    
    // Получение списка таблиц
    Tables = Source{[Schema="",Item=""]}[Data]
in
    Tables

// ========================================
// 2. ЗАГРУЗКА КОНКРЕТНОЙ ТАБЛИЦЫ
// ========================================

// Загрузка таблицы customers с преобразованием типов
let
    DatabasePath = "C:\path\to\your\ecommerce_database.db",
    Source = Sqlite.Database(File.Contents(DatabasePath)),
    
    // Выбираем таблицу customers
    customers_table = Source{[Schema="",Item="customers"]}[Data],
    
    // Преобразуем типы данных
    #"Changed Types" = Table.TransformColumnTypes(customers_table, {
        {"customer_id", Int64.Type},
        {"first_name", type text},
        {"last_name", type text},
        {"email", type text},
        {"city", type text},
        {"gender", type text},
        {"registration_date", type date}
    })
in
    #"Changed Types"

// ========================================
// 3. ВЫПОЛНЕНИЕ SQL ЗАПРОСА
// ========================================

// Базовый SQL запрос для анализа продаж по месяцам
let
    DatabasePath = "C:\path\to\your\ecommerce_database.db",
    
    // SQL запрос для месячной статистики
    SqlQuery = "
    SELECT 
        strftime('%Y-%m', order_date) AS YearMonth,
        strftime('%Y', order_date) AS Year,
        strftime('%m', order_date) AS Month,
        COUNT(*) AS OrdersCount,
        COUNT(DISTINCT customer_id) AS UniqueCustomers,
        SUM(total_amount) AS TotalRevenue,
        AVG(total_amount) AS AvgOrderValue,
        MIN(total_amount) AS MinOrderValue,
        MAX(total_amount) AS MaxOrderValue
    FROM orders
    WHERE order_date >= '2023-01-01'
    GROUP BY strftime('%Y-%m', order_date)
    ORDER BY YearMonth
    ",
    
    // Выполнение запроса
    Source = Sqlite.Database(File.Contents(DatabasePath), [Query=SqlQuery]),
    
    // Преобразование типов данных
    #"Changed Types" = Table.TransformColumnTypes(Source, {
        {"YearMonth", type text},
        {"Year", type text},
        {"Month", type text},
        {"OrdersCount", Int64.Type},
        {"UniqueCustomers", Int64.Type},
        {"TotalRevenue", type number},
        {"AvgOrderValue", type number},
        {"MinOrderValue", type number},
        {"MaxOrderValue", type number}
    }),
    
    // Добавляем столбец с названием месяца
    #"Added Month Name" = Table.AddColumn(#"Changed Types", "MonthName", each 
        if [Month] = "01" then "Январь"
        else if [Month] = "02" then "Февраль"
        else if [Month] = "03" then "Март"
        else if [Month] = "04" then "Апрель"
        else if [Month] = "05" then "Май"
        else if [Month] = "06" then "Июнь"
        else if [Month] = "07" then "Июль"
        else if [Month] = "08" then "Август"
        else if [Month] = "09" then "Сентябрь"
        else if [Month] = "10" then "Октябрь"
        else if [Month] = "11" then "Ноябрь"
        else "Декабрь"
    )
in
    #"Added Month Name"

// ========================================
// 4. ПАРАМЕТРИЗОВАННЫЙ ЗАПРОС
// ========================================

// Создание параметров для динамических запросов
// Сначала создайте параметры в Power Query:
// - StartDate (type: Date)
// - EndDate (type: Date)  
// - MinOrderAmount (type: Number)

let
    DatabasePath = "C:\path\to\your\ecommerce_database.db",
    
    // Преобразование параметров в строки для SQL
    StartDateText = Date.ToText(StartDate, "yyyy-MM-dd"),
    EndDateText = Date.ToText(EndDate, "yyyy-MM-dd"),
    MinAmountText = Number.ToText(MinOrderAmount),
    
    // Динамический SQL запрос с параметрами
    SqlQuery = "
    SELECT 
        c.customer_id,
        c.first_name || ' ' || c.last_name AS CustomerName,
        c.city,
        COUNT(o.order_id) AS OrdersCount,
        SUM(o.total_amount) AS TotalSpent,
        AVG(o.total_amount) AS AvgOrderValue,
        MIN(o.order_date) AS FirstOrder,
        MAX(o.order_date) AS LastOrder
    FROM customers c
    INNER JOIN orders o ON c.customer_id = o.customer_id
    WHERE o.order_date >= '" & StartDateText & "'
      AND o.order_date <= '" & EndDateText & "'
      AND o.total_amount >= " & MinAmountText & "
    GROUP BY c.customer_id, c.first_name, c.last_name, c.city
    ORDER BY TotalSpent DESC
    ",
    
    Source = Sqlite.Database(File.Contents(DatabasePath), [Query=SqlQuery]),
    
    #"Changed Types" = Table.TransformColumnTypes(Source, {
        {"customer_id", Int64.Type},
        {"CustomerName", type text},
        {"city", type text},
        {"OrdersCount", Int64.Type},
        {"TotalSpent", type number},
        {"AvgOrderValue", type number},
        {"FirstOrder", type date},
        {"LastOrder", type date}
    })
in
    #"Changed Types"

// ========================================
// 5. КОМПЛЕКСНЫЙ ЗАПРОС ДЛЯ ДАШБОРДА
// ========================================

// Данные для создания дашборда продаж по категориям и городам
let
    DatabasePath = "C:\path\to\your\ecommerce_database.db",
    
    SqlQuery = "
    SELECT 
        cat.category_name AS CategoryName,
        c.city AS City,
        strftime('%Y-%m', o.order_date) AS YearMonth,
        COUNT(DISTINCT o.order_id) AS OrdersCount,
        COUNT(DISTINCT o.customer_id) AS UniqueCustomers,
        SUM(oi.quantity) AS ItemsSold,
        SUM(oi.quantity * oi.price) AS Revenue,
        AVG(oi.price) AS AvgItemPrice,
        COUNT(DISTINCT oi.product_id) AS UniqueProducts
    FROM categories cat
    INNER JOIN products p ON cat.category_id = p.category_id
    INNER JOIN order_items oi ON p.product_id = oi.product_id
    INNER JOIN orders o ON oi.order_id = o.order_id
    INNER JOIN customers c ON o.customer_id = c.customer_id
    WHERE o.order_date >= '2023-01-01'
      AND c.city IN ('Москва', 'Санкт-Петербург', 'Новосибирск', 'Екатеринбург', 'Казань')
    GROUP BY cat.category_name, c.city, strftime('%Y-%m', o.order_date)
    ORDER BY YearMonth, CategoryName, City
    ",
    
    Source = Sqlite.Database(File.Contents(DatabasePath), [Query=SqlQuery]),
    
    #"Changed Types" = Table.TransformColumnTypes(Source, {
        {"CategoryName", type text},
        {"City", type text},
        {"YearMonth", type text},
        {"OrdersCount", Int64.Type},
        {"UniqueCustomers", Int64.Type},
        {"ItemsSold", Int64.Type},
        {"Revenue", type number},
        {"AvgItemPrice", type number},
        {"UniqueProducts", Int64.Type}
    }),
    
    // Добавляем вычисляемые столбцы
    #"Added Date Column" = Table.AddColumn(#"Changed Types", "Date", each 
        Date.FromText([YearMonth] & "-01")
    ),
    
    #"Added Revenue Per Customer" = Table.AddColumn(#"Added Date Column", "RevenuePerCustomer", each 
        if [UniqueCustomers] > 0 then [Revenue] / [UniqueCustomers] else 0
    ),
    
    #"Final Types" = Table.TransformColumnTypes(#"Added Revenue Per Customer", {
        {"Date", type date},
        {"RevenuePerCustomer", type number}
    })
in
    #"Final Types"

// ========================================
// 6. ФУНКЦИЯ ДЛЯ АВТООБНОВЛЕНИЯ
// ========================================

// Создание функции для переиспользования подключения
let
    // Функция принимает путь к базе и SQL запрос
    ConnectToSQLite = (DatabasePath as text, SqlQuery as text) as table =>
    let
        Source = Sqlite.Database(File.Contents(DatabasePath), [Query=SqlQuery])
    in
        Source,
    
    // Пример использования функции
    DatabasePath = "C:\path\to\your\ecommerce_database.db",
    
    Query = "
    SELECT 
        city,
        COUNT(*) as CustomersCount,
        COUNT(CASE WHEN gender = 'M' THEN 1 END) as MaleCount,
        COUNT(CASE WHEN gender = 'F' THEN 1 END) as FemaleCount
    FROM customers
    GROUP BY city
    ORDER BY CustomersCount DESC
    ",
    
    Result = ConnectToSQLite(DatabasePath, Query)
in
    Result

// ========================================
// 7. ОБРАБОТКА ОШИБОК
// ========================================

// Запрос с обработкой ошибок подключения
let
    DatabasePath = "C:\path\to\your\ecommerce_database.db",
    
    SqlQuery = "SELECT COUNT(*) as TotalCustomers FROM customers",
    
    // Попытка подключения с обработкой ошибок
    Source = try Sqlite.Database(File.Contents(DatabasePath), [Query=SqlQuery])
              otherwise #table({"Error"}, {{"Не удалось подключиться к базе данных"}}),
    
    // Проверка успешности подключения
    Result = if Value.Is(Source, type table) 
             then Source 
             else #table({"Message"}, {{"Проверьте путь к файлу базы данных"}})
in
    Result

// ========================================
// 8. НАСТРОЙКА АВТООБНОВЛЕНИЯ
// ========================================

// Для настройки автообновления в Power BI:
// 1. Опубликуйте отчет в Power BI Service
// 2. Настройте шлюз данных (Personal Gateway)
// 3. В настройках датасета включите запланированное обновление
// 4. Укажите частоту обновления (ежедневно, еженедельно, etc.)

// Для локального автообновления в Power BI Desktop:
// - Данные -> Обновить все (или Ctrl+F5)

// ========================================
// 9. ПОЛЕЗНЫЕ ТРАНСФОРМАЦИИ
// ========================================

// Добавление полезных вычисляемых столбцов
let
    DatabasePath = "C:\path\to\your\ecommerce_database.db",
    
    SqlQuery = "
    SELECT 
        customer_id,
        first_name,
        last_name,
        email,
        city,
        gender,
        registration_date
    FROM customers
    ",
    
    Source = Sqlite.Database(File.Contents(DatabasePath), [Query=SqlQuery]),
    
    // Добавляем полное имя
    #"Added Full Name" = Table.AddColumn(Source, "FullName", each 
        [first_name] & " " & [last_name]
    ),
    
    // Добавляем возраст аккаунта в днях
    #"Added Account Age" = Table.AddColumn(#"Added Full Name", "AccountAgeDays", each 
        Duration.Days(DateTime.LocalNow() - DateTime.From([registration_date]))
    ),
    
    // Добавляем сегмент по возрасту аккаунта
    #"Added Segment" = Table.AddColumn(#"Added Account Age", "CustomerSegment", each 
        if [AccountAgeDays] < 30 then "Новый"
        else if [AccountAgeDays] < 365 then "Активный"
        else "Старый"
    ),
    
    // Финальное преобразование типов
    #"Final Types" = Table.TransformColumnTypes(#"Added Segment", {
        {"customer_id", Int64.Type},
        {"FullName", type text},
        {"AccountAgeDays", Int64.Type},
        {"CustomerSegment", type text},
        {"registration_date", type date}
    })
in
    #"Final Types"

// ========================================
// 10. СОЗДАНИЕ MEASURES В POWER BI
// ========================================

// После загрузки данных создайте эти меры в Power BI:

// Total Revenue = SUM('orders'[total_amount])
// Average Order Value = AVERAGE('orders'[total_amount])
// Total Customers = DISTINCTCOUNT('customers'[customer_id])
// Total Orders = COUNT('orders'[order_id])
// Revenue Growth % = 
//     VAR CurrentRevenue = [Total Revenue]
//     VAR PreviousRevenue = CALCULATE([Total Revenue], PREVIOUSMONTH('orders'[order_date]))
//     RETURN DIVIDE(CurrentRevenue - PreviousRevenue, PreviousRevenue, 0)

// ========================================
// ПРИМЕЧАНИЯ ПО ИСПОЛЬЗОВАНИЮ
// ========================================

/*
1. ЗАМЕНИТЕ ПУТЬ К ФАЙЛУ:
   Обязательно замените "C:\path\to\your\ecommerce_database.db" 
   на реальный путь к вашему файлу базы данных

2. СОЗДАНИЕ ПАРАМЕТРОВ:
   В Power Query: Главная -> Управление параметрами -> Создать параметр
   
3. ТИПЫ ДАННЫХ:
   Всегда проверяйте и корректируйте типы данных после загрузки

4. ПРОИЗВОДИТЕЛЬНОСТЬ:
   Для больших данных используйте фильтрацию в SQL запросе,
   а не в Power Query

5. БЕЗОПАСНОСТЬ:
   Не храните чувствительные данные в SQL запросах
   Используйте параметры для динамических значений

6. ОБНОВЛЕНИЕ:
   Настройте автоматическое обновление данных
   Проверяйте логи обновления на ошибки

7. СВЯЗИ:
   В Power BI создайте связи между таблицами
   для корректной работы мер и визуализаций
*/